# ➲ let 和 const

## 1. let

ES6 通过 `let` 关键字声明变量

let 关键字定义的变量不存在变量名的提升

```js
console.log(x);//ReferenceError: Cannot access 'x' before initialization
let x = 10;
```

let 定义的变量在相同作用域内不可重复

```js
let x = 10;
let x = 10;//SyntaxError: Identifier 'x' has already been declared
```

let 形成块级作用域

```js
let x = 10;
{
  console.log(x);//ReferenceError: Cannot access 'x' before initialization
  let x = 10;
}
```

## 2. const

ES6 通过 `const` 关键字声明常量，常量一旦声明，不可修改。

```js
const x = 10;
x = 20;//TypeError: Assignment to constant variable.
```

> 提示：默认使用 const，只有当确实需要改变变量的值的时候才使用 let。

# ➲ 变量解构

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。

## 1. 解构示例

**➦ 解构数组**

```js
let [id, name, skill] = [1, "李白", "青莲剑客"];
console.log(id, name, skill); 
// 1 李白 青莲剑客
```

**➦ 解构对象**

```js
let {name, address, tel} = {
    name: "木子李",
    address: "成都市高新区雅和南四路216号",
    tel: "15228885771"
};
console.log(name, address, tel);
// 木子李 成都市高新区雅和南四路216号 15228885771
```

**➦ 设置默认值**：

```js
let {name = "李鸿耀", address, tel} = {
    address: "成都市高新区雅和南四路216号",
    tel: "15228885771"
};
console.log(name, address, tel);
// 李鸿耀 成都市高新区雅和南四路216号 15228885771
```

**➦ 解构字符串**

```javascript
let [a,b,c,d,e] = "CHINA";
console.log(a, b, c, d, e);
// C H I N A
```

## 2. 用途

**➦ 交换值**

```javascript
let x = 10, y = 20;
[x, y] = [y, x];
console.log(x, y);
// 20 10
```

**➦ 函数返回值**

```js
function conditions() {
    let min = 18, max = 50;
    return {min, max};
}
console.log(conditions());
// { min: 18, max: 50 }
```

**➦ 函数参数**

```javascript
function sum([a, b]) {
    return a + b;
}
console.log(sum([1, 2])); // 3
```

**➦ 提取JSON数据**

解构赋值对提取JSON对象中的数据，尤其有用。

```javascript
let json = {
    "status": "200",
    "data": {
        username: "lihy",
        nikename: "木子李",
        origin: "四川省成都市"
    }
}
let {status, data} = json;
console.log(status,data);
// 200 { username: 'lihy', nikename: '木子李', origin: '四川省成都市' }
```

# ➲ 字符串

## 1. 模板字符串

模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。

```javascript
// 1、普通字符串
const str1 = `Hello, world!`;
// 2、字符串中嵌入变量
const str2 = `Admin`;
const str3 = `Hello, ${name}!`;
```

> 提示：
>
> 1、模板字符串中嵌入变量使用 `${}`，`${}` 中可以是变量或表达式。
>
> 2、如果使用模板字符串表示多行字符串，所有的空格、缩进和换行都会保留在输出之中。

在模板字符串中，还可以嵌套函数，如下所示：

```javascript
let getName = () => `Henrry Lee`;
let str = `Hello, ${ getName() }!`;
console.log(str); // Hello, Henrry Lee!
```

## 2. 新增API

- [String.prototype.includes()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes)
- [String.prototype.startsWith()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith)
- [String.prototype.endsWith()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)
- [String.prototype.repeat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/repeat)
- [String.prototype.padStart()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart)
- [String.prototype.padEnd()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd)

# ➲ 数值类型

## 1. 新增API

- [Number.parseInt()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseint)
- [Number.parseFloat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat)

- [Number.isNaN()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)
- [Number.isInteger()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger)

## 2. 指数运算

```js
2 ** 2 // 4  相当于 Math.pow(2, 2);
2 ** 3 // 8  相当于 Math.pow(2, 3);
```

# ➲ Math

- [Math.trunc()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc)：去除小数部分，返回整数部分
- [Math.sign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/sign)：判断一个数是正数、负数还是零。

# ➲ Functions

## 1. 箭头函数

ES6允许使用箭头（`=>`）定义函数，其语法形式为：

```javascript
let function_name = (arguments) => { body }
```

示例代码：

```javascript
let sum = (a, b) => { return a + b; }  
// 等价于
function sum(a, b) { return a + b; }
```

提示：

如果只有1个参数，可以省略参数圆括号。

```js
let fn = res => {console.log(res);}
```

如果函数体只有一行return语句，可以省略函数体花括号和return关键字。

```
let sum = (a, b) => a + b;
```

> 注意：
>
> 1、箭头函数定义在哪个对象上，`this` 关键字就指向哪个对象。
>
> 2、不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。
>
> 3、不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。

**箭头函数不适用场景** *

由于箭头函数使得 `this` 从“动态”变成“静态”，下面两个场合不应该使用箭头函数。

\> 第一个场合是定义函数的方法，且该方法内部包括`this`。

```javascript
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}
```

上面代码中，`cat.jumps()`方法是一个箭头函数，这是错误的。调用`cat.jumps()`时，如果是普通函数，该方法内部的`this`指向`cat`；如果写成上面那样的箭头函数，使得`this`指向全局对象，因此不会得到预期结果。

\> 第二个场合是需要动态`this`的时候，也不应使用箭头函数。

```javascript
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});
```

上面代码运行时，点击按钮会报错，因为`button`的监听函数是一个箭头函数，导致里面的`this`就是全局对象。如果改成普通函数，`this` 就会动态指向被点击的按钮对象。

另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。

## 2. 默认值

```javascript
function sum(a = 0, b = 0) {
    return a + b;
}
console.log(sum()); // 0 
console.log(sum(10, 5)); // 15
```

> 提示：只能给函数尾参设置默认值，如果设置默认值的参数不是尾参，那么也要使用对位传参的形式给其他参数设置“undefined”；

## 3. rest 参数

ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

```javascript
function sum(...nums) {
    console.log(nums);
}
sum(1, 2, 3, 4); // [1, 2, 3, 4] -> Array
```

## 4. 扩展运算符

扩展运算符是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。下面示例是一些使用示例：

```js
// 1. 序列化数组
console.log(...[1, 2, 3]); // 1 2 3

// 2. 合并对象
let o1 = {name: "木子李", major: "Web前端"};
let o2 = {...o1, address: "成都市高新区"};
console.log(o2); // {name: "木子李", major: "Web前端", address: "成都市高新区"}

// 3. 合并数组
let nums1 = [1, 2], nums2 = [3, 4];
console.log([...nums1, ...nums2]); // [1, 2, 3, 4]
 
// 4. 字符串
console.log(..."CHINA"); // C H I N A

// 5. 将类似数组转为数组对象
let els = [...document.querySelectorAll(".list li")];

// 6. 复制数组
let arr = [1, 2, 3];
let newArr = [...arr]; 
console.log(newArr); // [1, 2, 3];
```

# ➲ 数组

## 1. 静态方法

- [Array.from()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)：将类似数组转变为真正的数组；
- [Array.of()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of)：将一组值，转换为数组

## 2. 实例方法

- [Array.prototype.copyWithin()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)：将数组内的某组元素复制替换到指定位置。
- [Array.prototype.find()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find)：返回数组中满足提供的测试函数的第一个元素的值。
- [Array.prototype.findIndex()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)：返回数组中满足提供的测试函数的第一个元素的**索引**。若没有找到对应元素则返回-1。
- [Array.prototype.includes()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)：判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。
- [Array.prototype.entries()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)：返回一个新的**Array Iterator**对象，该对象包含数组中每个索引的键/值对。
- [Array.prototype.keys()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys)：返回一个包含数组中每个索引键的**Array Iterator**对象。
- [Array.prototype.values()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values)：返回一个新的 **`Array Iterator`** 对象，该对象包含数组每个索引的值
- [Array.prototype.fill()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)：该方法使用给定值，填充一个数组。
- [Array.prototype.every()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every)：测试一个数组内的**所有元素**是否都能通过某个指定函数的测试。它返回一个布尔值。
- [Array.prototype.some()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some)：测试数组中是不是**至少有1个**元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。
- [Array.prototype.flat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)：按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。
- [Array.prototype.map()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)：创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
- [Array.prototype.filter()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)：过滤数组元素
- [Array.prototype.reduce()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)：对数组中的每个元素执行一个由您提供的**reducer**函数(升序执行)，将其结果汇总为单个返回值。

# ➲  Object

## 1. 属性简写

```js
let name    = "Muzili", age = 29;
let person  = { name, age };
person // {name: "Muzili", age: 28}
```

上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。这种简写在函数中非常实用，比如要同时返回最大值和最小值：

```js
let getMinAndMaxInArr = (nums) => {
    let min  = ...;
    let max  = ...;
    return { min, max };
}
```

处理属性可以简写，方法也可以简写：

```js
let person = {
  name: "Muzili",
  showName() {
    console.log(`My name is ${this.name}.`);
  }
}
```

## 2. 属性名表达式

JavaScript语言定义对象的属性，有两种方法。

```js
// methos 1
per.nickname = "Muzili";
// methos 2
per["nike" + "name] = "Muzili";
```

> 注意：
>
> 1. 字面量定义对象时，ES5中只能直接使用标识符作为属性名，在ES6中允许使用表达式作为属性名。
>
> 2. 表达式也可以用于定义方法名：
>
>    ```js
>    const per = {
>      ["show" + "Name"]() {}
>    }
>    ```

## 3. 类方法

### 3.1、Object.is()

ES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。`Object.is()` 用来比较两个值是否严格相等，与严格比较运算符的行为基本一致。

```js
+0 === -0;
// true
NaN === NaN
// false

Object.is(+0, -0);
// false
Object.is(NaN, NaN);
// true
```

### 3.2、Object.assign()

`Object.assign`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）语法形式如下：

```js
Object.assign(target, source1, source2, ?source3)
```

第一个参数为目标对象，后续所有参数为源对象。

```js
let target  = {city: "四川省成都市"}

let source1 = {name: "Henry"};
let source2 = {job: "Web前端工程师"};
Object.assign(target, source1, source2);
// {city: "四川省成都市", name: "Henry", job: "Web前端工程师"}
```

> 注意：
>
> 1. 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
> 2. `Object.assign` 方法是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。

`Object.assign` 用处很多，比如：

-> a. 为对象添加属性

```js
let obj = {
    nikename: "木子李"
}
Object.assign(obj, {age: 26});
console.log(obj); // {nikename: "木子李", age: 26}
```

-> b. 为对象添加新的方法

```js
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
```

-> c. 合并多个对象

将多个对象合并到某个对象。

```js
const merge = (target, ...sources) => Object.assign(target, ...sources);
```

如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并

```js
const merge = (...sources) => Object.assign({}, ...sources);
```

-> d. 为属性设置默认值

```js
function flash(options) {
    const DEFAULT = {
        duration: 1000,
        type: "scroll"
    };
    options = Object.assign({}, DEFAULT, options);
}
```

# ➲  Symbol

## 1. 概述

ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。

Symbol 值通过`Symbol`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

```js
let s = Symbol();
typeof s; // "symbol"
```

上面代码中，变量`s`就是一个独一无二的值。`typeof`运算符的结果，表明变量`s`是 Symbol 数据类型，而不是字符串之类的其他类型。

> 注意：Symbol 函数前不能使用`new`命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。

注意，`Symbol`函数前不能使用`new`命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。

```js
let s1 = Symbol('foo');
let s2 = Symbol('bar');

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // "Symbol(foo)"
s2.toString() // "Symbol(bar)"
```

上面代码中，`s1`和`s2`是两个 Symbol 值。如果不加参数，它们在控制台的输出都是`Symbol()`，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。

如果 Symbol 的参数是一个对象，就会调用该对象的`toString`方法，将其转为字符串，然后才生成一个 Symbol 值。

```js
const obj = {
  toString() {
    return 'abc';
  }
};
const sym = Symbol(obj);
sym // Symbol(abc)
```

> 注意：`Symbol`函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的`Symbol`函数的返回值是不相等的。

```js
// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol('foo');
let s2 = Symbol('foo');

s1 === s2 // false
```

上面代码中，`s1`和`s2`都是`Symbol`函数的返回值，而且参数相同，但是它们是不相等的。

## 2. 唯一值

```js
// bad
// 1. 创建的属性会被 for-in 或 Object.keys() 枚举出来
// 2. 一些库可能在将来会使用同样的方式，这会与你的代码发生冲突
if (element.isMoving) {
  smoothAnimations(element);
}
element.isMoving = true;

// good
if (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) {
  smoothAnimations(element);
}
element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true;

// better
var isMoving = Symbol("isMoving");


if (element[isMoving]) {
  smoothAnimations(element);
}
element[isMoving] = true;

```

## 3. 魔术字符串

魔术字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。

魔术字符串不利于修改和维护，风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。

```js
// bad
const TYPE_AUDIO = "AUDIO";
const TYPE_VIDEO = "VIDEO";
const TYPE_IMAGE = "IMAGE";

// good
const TYPE_AUDIO = Symbol();
const TYPE_VIDEO = Symbol();
const TYPE_IMAGE = Symbol();

function handleFileResource(resource) {
  switch (resource.type) {
    case TYPE_AUDIO:
      playAudio(resource);
      break;
    case TYPE_VIDEO:
      playVideo(resource);
      break;
    case TYPE_IMAGE:
      previewImage(resource);
      break;
    default:
      throw new Error("Unknown type of resource");
  }
}
```

## 4. 私有变量

Symbol 也可以用于私有变量的实现。

```js
const Example = (function () {
  var _private = Symbol("private");

  class Example {
    constructor() {
      this[_private] = "private";
    }
    getName() {
      return this[_private];
    }
  }

  return Example;
})();

var ex = new Example();

console.log(ex.getName()); // private
console.log(ex.name); // undefined
```

# ➲  Promise

## 1. 概述

JavaScript 是单线程工作，这意味着两段脚本不能同时运行，而是必须一个接一个地运行。Promise是异步编程的一种解决方案，比传统的解决方案 **回调函数和事件** 更合理、更强大。其优雅的解决了回调嵌套的问题。

**➦  状态**

- pending：进行中
- resolved：成功
- rejected：失败

有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数（回调地狱）。

**➦  缺陷**

- 无法取消
- 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。
- 当处于`Pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

**➦  浏览器兼容**

现在，promise 已在各浏览器中实现。

自 Chrome 32、Opera 19、Firefox 29、Safari 8 和 Microsoft Edge 起，promise 默认启用。

如要使没有完全实现 promise 的浏览器符合规范，或向其他浏览器和 Node.js 中添加 promise，请查看 [polyfill](https://github.com/jakearchibald/ES6-Promises#readme)。

## 2. 用法

语法形式：

```js
const promise = new Promise((resolve, reject) => {
  // ... some code
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
})
```

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

- resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
- reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

Promise实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。

```js
promise.then(() => {
  // success
}, error => {
  // fail
});
```

then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。

**eg：XMLHttpRequest 执行 Promise**

```js
function get(url) {
    return new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.send();
        xhr.addEventListener("load", () => {
            if(xhr.status === 200) {
                resolve(xhr.response);
            }else {
                reject(Error(xhr.statusText));
            }
        });
        xhr.addEventListener("error", () => {
            reject(Error("network err!"));
        });
    })
}
```

现在让我们来使用这一功能：

```js
get("./data.json").then(data => {
    console.log(data)
}, err => {
    console.log(err);
});
```

## 3. then

`then()` 不是最终部分，你可以将各个 `then` 链接在一起来改变值，或依次运行额外的异步操作。

### 3.1. 改变值

只需返回新值即可改变值：

```js
let promise = new Promise((resolve, reject) => {
    resolve(1);
});

promise.then(val => val + 1).then(val => {
    console.log(val); // 2
});
```

举一个实际的例子，上文中我们封装的 `get` 函数返回的是一个JSON，那我们需要对其进行JSON解析的处理，如下所示：

```js
get("./data.json").then(response => {
    return JSON.parse(response);
}).then(result => {
    console.log(result);
});
```

由于 `JSON.parse()` 采用单一参数并返回改变的值，因此我们可以将其简化为：

```js
get("./data.json").then(JSON.parse).then(result => {
    console.log("result:", result);
})
```

### 3.2. 异步操作队列

您还可以链接多个 `then`，以便按顺序运行异步操作。

```js
function t1() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("t1");
            resolve("t1成功后返回的内容！");
        }, 1500);
    })
}
function t2() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("t2");
            resolve("t2成功后返回的内容！");
        }, 500);
    })
}
function t3() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("t3");
            resolve("t3成功后返回的内容！");
        }, 1000);
    })
}

// 连续调用
t1().then(data => {
    console.log(data);
    return t2();
}).then(data => {
    console.log(data);
    return t3();
}).then(data => {
    console.log(data);
})
/* 
t1
t1成功后返回的内容！
t2
t2成功后返回的内容！
t3
t3成功后返回的内容！ */
```

## 4. catch

`then()` 包含两个参数：一个用于成功，一个用于失败：

```js
promise.then(() => {
  // success
}, error => {
  // fail
});
```

当然我们也可以使用 `catch()`：

```js
promise.then(() => {
    // success
}).catch(err => {
    console.log(err);
});
```

## 5. Promise.all()

`Promise.all` 包含一组 promise，并创建一个在所有内容成功完成后执行的 promise。 您将获得一组结果（即一组 promise 执行的结果），其顺序与您与传入 promise 的顺序相同。

```js
Promise.all(arrayOfPromises).then(arrayOfResults => {
  //...
})
```

示例：

```js
//通过all方法调用 注意 这个方式是并行执行的 无法决定顺序
Promise.all([t1(), t3(), t3()]).then(function (results) {
    console.log(results);
});
```













