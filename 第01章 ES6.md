# ➲ let 和 const

## 1. let

ES6 通过 `let` 关键字声明变量

let 关键字定义的变量不存在变量名的提升

```js
console.log(x);//ReferenceError: Cannot access 'x' before initialization
let x = 10;
```

let 定义的变量在相同作用域内不可重复

```js
let x = 10;
let x = 10;//SyntaxError: Identifier 'x' has already been declared
```

let 形成块级作用域

```js
let x = 10;
{
  console.log(x);//ReferenceError: Cannot access 'x' before initialization
  let x = 10;
}
```

## 2. const

ES6 通过 `const` 关键字声明常量，常量一旦声明，不可修改。

```js
const x = 10;
x = 20;//TypeError: Assignment to constant variable.
```

> 提示：默认使用 const，只有当确实需要改变变量的值的时候才使用 let。

# ➲ 变量解构

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构。

## 1. 解构示例

**➦ 解构数组**

```js
let [id, name, skill] = [1, "李白", "青莲剑客"];
console.log(id, name, skill); 
// 1 李白 青莲剑客
```

**➦ 解构对象**

```js
let {name, address, tel} = {
    name: "木子李",
    address: "成都市高新区雅和南四路216号",
    tel: "15228885771"
};
console.log(name, address, tel);
// 木子李 成都市高新区雅和南四路216号 15228885771
```

**➦ 设置默认值**：

```js
let {name = "李鸿耀", address, tel} = {
    address: "成都市高新区雅和南四路216号",
    tel: "15228885771"
};
console.log(name, address, tel);
// 李鸿耀 成都市高新区雅和南四路216号 15228885771
```

**➦ 解构字符串**

```javascript
let [a,b,c,d,e] = "CHINA";
console.log(a, b, c, d, e);
// C H I N A
```

## 2. 用途

**➦ 交换值**

```javascript
let x = 10, y = 20;
[x, y] = [y, x];
console.log(x, y);
// 20 10
```

**➦ 函数返回值**

```js
function conditions() {
    let min = 18, max = 50;
    return {min, max};
}
console.log(conditions());
// { min: 18, max: 50 }
```

**➦ 函数参数**

```javascript
function sum([a, b]) {
    return a + b;
}
console.log(sum([1, 2])); // 3
```

**➦ 提取JSON数据**

解构赋值对提取JSON对象中的数据，尤其有用。

```javascript
let json = {
    "status": "200",
    "data": {
        username: "lihy",
        nikename: "木子李",
        origin: "四川省成都市"
    }
}
let {status, data} = json;
console.log(status,data);
// 200 { username: 'lihy', nikename: '木子李', origin: '四川省成都市' }
```

# ➲ 字符串

## 1. 模板字符串

模板字符串是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。

```javascript
// 1、普通字符串
const str1 = `Hello, world!`;
// 2、字符串中嵌入变量
const str2 = `Admin`;
const str3 = `Hello, ${name}!`;
```

> 提示：
>
> 1、模板字符串中嵌入变量使用 `${}`，`${}` 中可以是变量或表达式。
>
> 2、如果使用模板字符串表示多行字符串，所有的空格、缩进和换行都会保留在输出之中。

在模板字符串中，还可以嵌套函数，如下所示：

```javascript
let getName = () => `Henrry Lee`;
let str = `Hello, ${ getName() }!`;
console.log(str); // Hello, Henrry Lee!
```

## 2. 新增API

- [String.prototype.includes()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes)
- [String.prototype.startsWith()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith)
- [String.prototype.endsWith()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)
- [String.prototype.repeat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/repeat)
- [String.prototype.padStart()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart)
- [String.prototype.padEnd()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd)

# ➲ 数值类型

## 1. 新增API

- [Number.parseInt()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseint)
- [Number.parseFloat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/parseFloat)

- [Number.isNaN()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN)
- [Number.isInteger()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger)

## 2. 指数运算

```js
2 ** 2 // 4  相当于 Math.pow(2, 2);
2 ** 3 // 8  相当于 Math.pow(2, 3);
```

# ➲ Math

- [Math.trunc()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc)：去除小数部分，返回整数部分
- [Math.sign()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/sign)：判断一个数是正数、负数还是零。

# ➲ Functions

## 1. 箭头函数

ES6允许使用箭头（`=>`）定义函数，其语法形式为：

```javascript
let function_name = (arguments) => { body }
```

示例代码：

```javascript
let sum = (a, b) => { return a + b; }  
// 等价于
function sum(a, b) { return a + b; }
```

提示：

如果只有1个参数，可以省略参数圆括号。

```js
let fn = res => {console.log(res);}
```

如果函数体只有一行return语句，可以省略函数体花括号和return关键字。

```
let sum = (a, b) => a + b;
```

> 注意：
>
> 1、箭头函数定义在哪个对象上，`this` 关键字就指向哪个对象。
>
> 2、不可以当作构造函数，也就是说，不可以使用`new`命令，否则会抛出一个错误。
>
> 3、不可以使用`arguments`对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。

**箭头函数不适用场景** *

由于箭头函数使得 `this` 从“动态”变成“静态”，下面两个场合不应该使用箭头函数。

\> 第一个场合是定义函数的方法，且该方法内部包括`this`。

```javascript
const cat = {
  lives: 9,
  jumps: () => {
    this.lives--;
  }
}
```

上面代码中，`cat.jumps()`方法是一个箭头函数，这是错误的。调用`cat.jumps()`时，如果是普通函数，该方法内部的`this`指向`cat`；如果写成上面那样的箭头函数，使得`this`指向全局对象，因此不会得到预期结果。

\> 第二个场合是需要动态`this`的时候，也不应使用箭头函数。

```javascript
var button = document.getElementById('press');
button.addEventListener('click', () => {
  this.classList.toggle('on');
});
```

上面代码运行时，点击按钮会报错，因为`button`的监听函数是一个箭头函数，导致里面的`this`就是全局对象。如果改成普通函数，`this` 就会动态指向被点击的按钮对象。

另外，如果函数体很复杂，有许多行，或者函数内部有大量的读写操作，不单纯是为了计算值，这时也不应该使用箭头函数，而是要使用普通函数，这样可以提高代码可读性。

## 2. 默认值

```javascript
function sum(a = 0, b = 0) {
    return a + b;
}
console.log(sum()); // 0 
console.log(sum(10, 5)); // 15
```

> 提示：只能给函数尾参设置默认值，如果设置默认值的参数不是尾参，那么也要使用对位传参的形式给其他参数设置“undefined”；

## 3. rest 参数

ES6 引入 rest 参数（形式为`...变量名`），用于获取函数的多余参数，这样就不需要使用`arguments`对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

```javascript
function sum(...nums) {
    console.log(nums);
}
sum(1, 2, 3, 4); // [1, 2, 3, 4] -> Array
```

## 4. 扩展运算符

扩展运算符是三个点（`...`）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。下面示例是一些使用示例：

```js
// 1. 序列化数组
console.log(...[1, 2, 3]); // 1 2 3

// 2. 合并对象
let o1 = {name: "木子李", major: "Web前端"};
let o2 = {...o1, address: "成都市高新区"};
console.log(o2); // {name: "木子李", major: "Web前端", address: "成都市高新区"}

// 3. 合并数组
let nums1 = [1, 2], nums2 = [3, 4];
console.log([...nums1, ...nums2]); // [1, 2, 3, 4]
 
// 4. 字符串
console.log(..."CHINA"); // C H I N A

// 5. 将类似数组转为数组对象
let els = [...document.querySelectorAll(".list li")];

// 6. 复制数组
let arr = [1, 2, 3];
let newArr = [...arr]; 
console.log(newArr); // [1, 2, 3];
```

# ➲ 数组

## 1. 静态方法

- [Array.from()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)：将类似数组转变为真正的数组；
- [Array.of()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/of)：将一组值，转换为数组

## 2. 实例方法

- [Array.prototype.copyWithin()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin)：将数组内的某组元素复制替换到指定位置。
- [Array.prototype.find()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find)：返回数组中满足提供的测试函数的第一个元素的值。
- [Array.prototype.findIndex()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex)：返回数组中满足提供的测试函数的第一个元素的**索引**。若没有找到对应元素则返回-1。
- [Array.prototype.includes()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/includes)：判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回false。
- [Array.prototype.entries()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/entries)：返回一个新的**Array Iterator**对象，该对象包含数组中每个索引的键/值对。
- [Array.prototype.keys()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/keys)：返回一个包含数组中每个索引键的**Array Iterator**对象。
- [Array.prototype.values()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/values)：返回一个新的 **`Array Iterator`** 对象，该对象包含数组每个索引的值
- [Array.prototype.fill()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/fill)：该方法使用给定值，填充一个数组。
- [Array.prototype.every()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every)：测试一个数组内的**所有元素**是否都能通过某个指定函数的测试。它返回一个布尔值。
- [Array.prototype.some()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some)：测试数组中是不是**至少有1个**元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。
- [Array.prototype.flat()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flat)：按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。
- [Array.prototype.map()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map)：创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
- [Array.prototype.filter()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)：过滤数组元素
- [Array.prototype.reduce()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)：对数组中的每个元素执行一个由您提供的**reducer**函数(升序执行)，将其结果汇总为单个返回值。

# ➲  Object

## 1. 属性简写

```js
let name    = "Muzili", age = 29;
let person  = { name, age };
person // {name: "Muzili", age: 28}
```

上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。这种简写在函数中非常实用，比如要同时返回最大值和最小值：

```js
let getMinAndMaxInArr = (nums) => {
    let min  = ...;
    let max  = ...;
    return { min, max };
}
```

处理属性可以简写，方法也可以简写：

```js
let person = {
  name: "Muzili",
  showName() {
    console.log(`My name is ${this.name}.`);
  }
}
```

## 2. 属性名表达式

JavaScript语言定义对象的属性，有两种方法。

```js
// methos 1
per.nickname = "Muzili";
// methos 2
per["nike" + "name] = "Muzili";
```

> 注意：
>
> 1. 字面量定义对象时，ES5中只能直接使用标识符作为属性名，在ES6中允许使用表达式作为属性名。
>
> 2. 表达式也可以用于定义方法名：
>
>    ```js
>    const per = {
>      ["show" + "Name"]() {}
>    }
>    ```

## 3. 类方法

### 3.1、Object.is()

ES5 比较两个值是否相等，只有两个运算符：相等运算符（`==`）和严格相等运算符（`===`）。它们都有缺点，前者会自动转换数据类型，后者的`NaN`不等于自身，以及`+0`等于`-0`。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。`Object.is()` 用来比较两个值是否严格相等，与严格比较运算符的行为基本一致。

```js
+0 === -0;
// true
NaN === NaN
// false

Object.is(+0, -0);
// false
Object.is(NaN, NaN);
// true
```

### 3.2、Object.assign()

`Object.assign`方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）语法形式如下：

```js
Object.assign(target, source1, source2, ?source3)
```

第一个参数为目标对象，后续所有参数为源对象。

```js
let target  = {city: "四川省成都市"}

let source1 = {name: "Henry"};
let source2 = {job: "Web前端工程师"};
Object.assign(target, source1, source2);
// {city: "四川省成都市", name: "Henry", job: "Web前端工程师"}
```

> 注意：
>
> 1. 如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。
> 2. `Object.assign` 方法是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。

`Object.assign` 用处很多，比如：

-> a. 为对象添加属性

```js
let obj = {
    nikename: "木子李"
}
Object.assign(obj, {age: 26});
console.log(obj); // {nikename: "木子李", age: 26}
```

-> b. 为对象添加新的方法

```js
Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
```

-> c. 合并多个对象

将多个对象合并到某个对象。

```js
const merge = (target, ...sources) => Object.assign(target, ...sources);
```

如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并

```js
const merge = (...sources) => Object.assign({}, ...sources);
```

-> d. 为属性设置默认值

```js
function flash(options) {
    const DEFAULT = {
        duration: 1000,
        type: "scroll"
    };
    options = Object.assign({}, DEFAULT, options);
}
```

# ➲  Symbol

## 1. 概述

ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入`Symbol`的原因。

Symbol 值通过`Symbol`函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。

```js
let s = Symbol();
typeof s; // "symbol"
```

上面代码中，变量`s`就是一个独一无二的值。`typeof`运算符的结果，表明变量`s`是 Symbol 数据类型，而不是字符串之类的其他类型。

> 注意：Symbol 函数前不能使用`new`命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。

注意，`Symbol`函数前不能使用`new`命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。

```js
let s1 = Symbol('foo');
let s2 = Symbol('bar');

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // "Symbol(foo)"
s2.toString() // "Symbol(bar)"
```

上面代码中，`s1`和`s2`是两个 Symbol 值。如果不加参数，它们在控制台的输出都是`Symbol()`，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。

如果 Symbol 的参数是一个对象，就会调用该对象的`toString`方法，将其转为字符串，然后才生成一个 Symbol 值。

```js
const obj = {
  toString() {
    return 'abc';
  }
};
const sym = Symbol(obj);
sym // Symbol(abc)
```

> 注意：`Symbol`函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的`Symbol`函数的返回值是不相等的。

```js
// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol('foo');
let s2 = Symbol('foo');

s1 === s2 // false
```

上面代码中，`s1`和`s2`都是`Symbol`函数的返回值，而且参数相同，但是它们是不相等的。

## 2. 唯一值

```js
// bad
// 1. 创建的属性会被 for-in 或 Object.keys() 枚举出来
// 2. 一些库可能在将来会使用同样的方式，这会与你的代码发生冲突
if (element.isMoving) {
  smoothAnimations(element);
}
element.isMoving = true;

// good
if (element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__) {
  smoothAnimations(element);
}
element.__$jorendorff_animation_library$PLEASE_DO_NOT_USE_THIS_PROPERTY$isMoving__ = true;

// better
var isMoving = Symbol("isMoving");


if (element[isMoving]) {
  smoothAnimations(element);
}
element[isMoving] = true;

```

## 3. 魔术字符串

魔术字符串指的是在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。

魔术字符串不利于修改和维护，风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。

```js
// bad
const TYPE_AUDIO = "AUDIO";
const TYPE_VIDEO = "VIDEO";
const TYPE_IMAGE = "IMAGE";

// good
const TYPE_AUDIO = Symbol();
const TYPE_VIDEO = Symbol();
const TYPE_IMAGE = Symbol();

function handleFileResource(resource) {
  switch (resource.type) {
    case TYPE_AUDIO:
      playAudio(resource);
      break;
    case TYPE_VIDEO:
      playVideo(resource);
      break;
    case TYPE_IMAGE:
      previewImage(resource);
      break;
    default:
      throw new Error("Unknown type of resource");
  }
}
```

## 4. 私有变量

Symbol 也可以用于私有变量的实现。

```js
const Example = (function () {
  var _private = Symbol("private");

  class Example {
    constructor() {
      this[_private] = "private";
    }
    getName() {
      return this[_private];
    }
  }

  return Example;
})();

var ex = new Example();

console.log(ex.getName()); // private
console.log(ex.name); // undefined
```

# ➲  Promise

## 1. 概述

JavaScript 是单线程工作，这意味着两段脚本不能同时运行，而是必须一个接一个地运行。Promise是异步编程的一种解决方案，比传统的解决方案 **回调函数和事件** 更合理、更强大。其优雅的解决了回调嵌套的问题。

**➦  状态**

- pending：进行中
- resolved：成功
- rejected：失败

有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数（回调地狱）。

**➦  缺陷**

- 无法取消
- 如果不设置回调函数，`Promise`内部抛出的错误，不会反应到外部。
- 当处于`Pending`状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

**➦  浏览器兼容**

现在，promise 已在各浏览器中实现。

自 Chrome 32、Opera 19、Firefox 29、Safari 8 和 Microsoft Edge 起，promise 默认启用。

如要使没有完全实现 promise 的浏览器符合规范，或向其他浏览器和 Node.js 中添加 promise，请查看 [polyfill](https://github.com/jakearchibald/ES6-Promises#readme)。

## 2. 用法

语法形式：

```js
const promise = new Promise((resolve, reject) => {
  // ... some code
  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
})
```

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。

- resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；
- reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

Promise实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。

```js
promise.then(() => {
  // success
}, error => {
  // fail
});
```

then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。

**eg：XMLHttpRequest 执行 Promise**

```js
function get(url) {
    return new Promise((resolve, reject) => {
        let xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.send();
        xhr.addEventListener("load", () => {
            if(xhr.status === 200) {
                resolve(xhr.response);
            }else {
                reject(Error(xhr.statusText));
            }
        });
        xhr.addEventListener("error", () => {
            reject(Error("network err!"));
        });
    })
}
```

现在让我们来使用这一功能：

```js
get("./data.json").then(data => {
    console.log(data)
}, err => {
    console.log(err);
});
```

## 3. then

`then()` 不是最终部分，你可以将各个 `then` 链接在一起来改变值，或依次运行额外的异步操作。

### 3.1. 改变值

只需返回新值即可改变值：

```js
let promise = new Promise((resolve, reject) => {
    resolve(1);
});

promise.then(val => val + 1).then(val => {
    console.log(val); // 2
});
```

举一个实际的例子，上文中我们封装的 `get` 函数返回的是一个JSON，那我们需要对其进行JSON解析的处理，如下所示：

```js
get("./data.json").then(response => {
    return JSON.parse(response);
}).then(result => {
    console.log(result);
});
```

由于 `JSON.parse()` 采用单一参数并返回改变的值，因此我们可以将其简化为：

```js
get("./data.json").then(JSON.parse).then(result => {
    console.log("result:", result);
})
```

### 3.2. 异步操作队列

您还可以链接多个 `then`，以便按顺序运行异步操作。

```js
function t1() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("t1");
            resolve("t1成功后返回的内容！");
        }, 1500);
    })
}
function t2() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("t2");
            resolve("t2成功后返回的内容！");
        }, 500);
    })
}
function t3() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log("t3");
            resolve("t3成功后返回的内容！");
        }, 1000);
    })
}

// 连续调用
t1().then(data => {
    console.log(data);
    return t2();
}).then(data => {
    console.log(data);
    return t3();
}).then(data => {
    console.log(data);
})
/* 
t1
t1成功后返回的内容！
t2
t2成功后返回的内容！
t3
t3成功后返回的内容！ */
```

## 4. catch

`then()` 包含两个参数：一个用于成功，一个用于失败：

```js
promise.then(() => {
  // success
}, error => {
  // fail
});
```

当然我们也可以使用 `catch()`：

```js
promise.then(() => {
    // success
}).catch(err => {
    console.log(err);
});
```

## 5. Promise.all()

`Promise.all` 包含一组 promise，并创建一个在所有内容成功完成后执行的 promise。 您将获得一组结果（即一组 promise 执行的结果），其顺序与您与传入 promise 的顺序相同。

```js
Promise.all(arrayOfPromises).then(arrayOfResults => {
  //...
})
```

示例：

```js
//通过all方法调用 注意 这个方式是并行执行的 无法决定顺序
Promise.all([t1(), t3(), t3()]).then(function (results) {
    console.log(results);
});
```

# ➲  Set

## 1. [Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)

### 1.1. 基本用法

ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

```js
const sets = new Set([1, 2, 2, 3, 4, 3, 5]);
sets
// Set(5) {1, 2, 3, 4, 5}
```

Set集合可通过数组或类似数组创建，通过Set，可以更加方便的实现数组去重。

```js
let nums = [1, 2, 3, 2, 1];
nums = [...new Set(nums)];
nums
// (3) [1, 2, 3]
```

### 1.2. 属性和方法

**➦  属性**

Set 结构的实例有以下属性。

- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。
- `Set.prototype.size`：返回`Set`实例的成员总数。

**➦  操作方法**

- `add(value)`：添加某个值，返回 Set 结构本身。
- `delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
- `clear()`：清除所有成员，没有返回值。

**➦  遍历方法**

Set 结构的实例有四个遍历方法，可以用于遍历成员。

- `keys()`：返回键名的遍历器
- `values()`：返回键值的遍历器
- `entries()`：返回键值对的遍历器
- `forEach()`：使用回调函数遍历每个成员

> 提示：需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。

### 1.3. 应用

**➦ 数组去重**

```js
[...new Set(array)]
```

**➦ 并集（Union）、交集（Intersect）和差集（Difference）**

```js
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);
// 并集
let union = new Set([...a, ...b]); // Set {1, 2, 3, 4}
// 交集
let intersect = new Set([...a].filter(x => b.has(x))); // set {2, 3}
// 差集
let difference = new Set([...a].filter(x => !b.has(x))); // Set {1}
```

## 2. [WeakSet](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet)

### 2.1. 含义

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

首先，<u>WeakSet 的成员只能是对象，而不能是其他类型的值</u>。

```js
const ws = new WeakSet();
ws.add(1) // TypeError: Invalid value used in weak set
ws.add(Symbol()) // TypeError: invalid value used in weak set
```

上面代码试图向 WeakSet 添加一个数值和`Symbol`值，结果报错，因为 WeakSet 只能放置对象。

其次，<u>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中</u>。

这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为`0`，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。

由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。

这些特点同样适用于本章后面要介绍的 WeakMap 结构。

### 2.2. 语法

WeakSet 是一个构造函数，可以使用 `new` 命令，创建 WeakSet 数据结构。

```js
const ws = new WeakSet();
```

作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。

```js
const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a); // WeakSet {[1, 2], [3, 4]}
```

上面代码中，`a`是一个数组，它有两个成员，也都是数组。将`a`作为 WeakSet 构造函数的参数，`a`的成员会自动成为 WeakSet 的成员。

> 注意：是`a`数组的成员成为 WeakSet 的成员，而不是`a`数组本身。这意味着，数组的成员只能是对象。

```js
const b = [3, 4];
const ws = new WeakSet(b); // Uncaught TypeError: Invalid value used in weak set(…)
```

上面代码中，数组`b`的成员不是对象，加入 WeaKSet 就会报错。

WeakSet 结构有以下三个方法。

- [WeakSet.prototype.add()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet/add)：向 WeakSet 实例添加一个新成员。
- [WeakSet.prototype.delete()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet/delete)：清除 WeakSet 实例的指定成员。
- [WeakSet.prototype.has()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet/has)：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。

```js
var ws = new WeakSet();
var foo = {};
var bar = {};

ws.add(foo);
ws.add(bar);

ws.has(foo);    // true
ws.has(bar);   // true

ws.delete(foo); // 从set中删除 foo 对象
ws.has(foo);    // false, foo 对象已经被删除了
ws.has(bar);    // true, bar 依然存在
```

WeakSet 没有`size`属性，没有办法遍历它的成员。WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

```js
const foos = new WeakSet();
class Foo {
  constructor() {
    foos.add(this);
  }
  method() {
    if (!foos.has(this)) {
      throw new TypeError("Foo.prototype.method 只能在Foo的实例上调用！");
    }
  }
}

```

上面代码保证了`Foo`的实例方法，只能在`Foo`的实例上调用。这里使用 WeakSet 的好处是，`foos`对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑`foos`，也不会出现内存泄漏。

# ➲  Map

## 1. Map

### 1.1. 含义和基本用法

JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。

```js
const data = {};
const key = {};
data[key] = "metadata";
data["[object Object]"]; // "metadata"
```

上面代码原意是将一个对象`key`作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`key`被自动转为字符串`[object Object]`。

为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

```js
let map = new Map();
let obj = { name: "Muzili" };
map.set(obj, "content"); // Map(1) {{…} => "content"}
map.get(obj); // "content"
map.has(obj); // true
map.delete(obj); // true
map; // Map(0) {}
```

上面代码使用 Map 结构的`set`方法，将对象`obj`当作`map`的一个键，然后又使用`get`方法读取这个键，接着使用`delete`方法删除了这个键。

上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。

```js
const map = new Map([  ['name', 'Henry'],  ['age', 28],  ['job','Web前端工程师']]);
// Map(3) {"name" => "Henry", "age" => 28, "job" => "Web前端工程师"}
```

`Map`构造函数接受数组作为参数，实际上执行的是下面的算法。

```js
const items = [  ['name', 'Henry'],  ['age', 28],  ['job','Web前端工程师']];
const map = new Map();
items.forEach(  ([key, value]) => map.set(key, value));
```

如果对同一个键多次赋值，后面的值将覆盖前面的值。

```js
const map = new Map();
map.set(1, 'aaa').set(1, 'bbb');
map.get(1) // "bbb"
```

上面代码对键`1`连续赋值两次，后一次的值覆盖前一次的值。

如果读取一个未知的键，则返回`undefined`。

```js
new Map().get('qwertyuio') // undefined
```

> 注意：只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

```js
const map = new Map();
map.set(['a'], 555);
map.get(['a']) // undefined
```

上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。

同理，同样的值的两个实例，在 Map 结构中被视为两个键。

```js
const map = new Map();
const k1 = ['a'];
const k2 = ['a'];
map.set(k1, 111).set(k2, 222);
map.get(k1) // 111
map.get(k2) // 222
```

上面代码中，变量`k1`和`k2`的值是一样的，但是它们在 Map 结构中被视为两个键。

由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键。

```js
let map = new Map();
map.set(-0, 123);
map.get(+0) // 123
map.set(true, 1);
map.set('true', 2);
map.get(true) // 1
map.set(undefined, 3);
map.set(null, 4);
map.get(undefined) // 3
map.set(NaN, 123);
map.get(NaN) // 123
```

### 1.2. 属性与方法

- [Map.prototype.size](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size)：返回 Map 结构的成员总数。

- [Map.prototype.set()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/set)：设置键名key对应的键值为value，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。

- [Map.prototype.get()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/get)：读取key对应的键值，如果找不到key，返回undefined。

- [Map.prototype.has()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/has)：返回一个布尔值，表示某个键是否在当前 Map 对象之中。

- [Map.prototype.delete()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/delete)：删除某个键，返回true。如果删除失败，返回false。

- [Map.prototype.clear()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/clear)：清除所有成员，没有返回值。

### 1.3. 遍历方法

Map 结构原生提供三个遍历器生成函数和一个遍历方法。

- `keys()`：返回键名的遍历器。
- `values()`：返回键值的遍历器。
- `entries()`：返回所有成员的遍历器。
- `forEach()`：遍历 Map 的所有成员。

### 1.4. Map 与其他数据类型转换

**➦ Map -> Array**

```js
let map = new Map();
map.set('name', 'Henry');
map.set('age', 28);
[...map] // [['name', 'Henry'], ['age', 28]]
```

**➦ Array -> Map**

```js
let map = new Map([
  ["name", "Henry"],
  ["age", 28],
]);
map; // Map(2) {"name" => "Henry", "age" => 28}
```

**➦ Map -> Object**

```js
function mapToObj(map) {
  let obj = Object.create(null);
  for (let [key, value] of map) {
    obj[key] = value;
  }
  return obj;
}
let map = new Map().set("name", "Henry").set("age", 28);
mapToObj(map);
// {name: "Henry", age: 28}
```

> 提示：如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。

**➦ Object -> Map**

```js
function objToMap(obj) {
  let map = new Map();
  for (let key of Object.keys(obj)) {
    map.set(key, obj[key]);
  }
  return map;
}
objToMap({ name: "Henry", age: 28 });
// Map(2) {"name" => "Henry", "age" => 28}
```

## 2. WeakMap

### 2.1. 含义

WeakMap结构与Map结构类似，也是用于生成键值对的集合。

WeakMap与Map的区别有两点。

首先，<u>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。</u>

```js
const map = new WeakMap();
map.set(1, 2) // TypeError: 1 is not an object!
map.set(Symbol(), 2) // TypeError: Invalid value used as weak map key
map.set(null, 2) // TypeError: Invalid value used as weak map key
```

上面代码中，如果将数值`1`和`Symbol`值作为 WeakMap 的键名，都会报错。

其次，<u>`WeakMap`的键名所指向的对象，不计入垃圾回收机制。</u>

`WeakMap`的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。

```js
const e1 = document.getElementById('foo');
const e2 = document.getElementById('bar');
const arr = [  [e1, 'foo 元素'],  [e2, 'bar 元素'],];
```

上面代码中，`e1`和`e2`是两个对象，我们通过`arr`数组对这两个对象添加一些文字说明。这就形成了`arr`对`e1`和`e2`的引用。

一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放`e1`和`e2`占用的内存。

```js
// 不需要 e1 和 e2 的时候
// 必须手动删除引用
arr [0] = null;
arr [1] = null;
```

上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。

WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用`WeakMap`结构。当该 DOM 元素被清除，其所对应的`WeakMap`记录就会自动被移除。

```js
const wm = new WeakMap();
const element = document.getElementById('example');
wm.set(element, 'some information');
wm.get(element) // "some information"
```

上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对`element`的引用就是弱引用，不会被计入垃圾回收机制。

也就是说，上面的 DOM 节点对象的引用计数是`1`，而不是`2`。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。

总之，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。

> 注意：WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。

```js
const wm = new WeakMap();
let key = {};
let obj = {foo: 1};
wm.set(key, obj);
obj = null;
wm.get(key)// Object {foo: 1}
```

上面代码中，键值`obj`是正常引用。所以，即使在 WeakMap 外部消除了`obj`的引用，WeakMap 内部的引用依然存在。

### 2.2. 语法

WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有`keys()`、`values()`和`entries()`方法），也没有`size`属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持`clear`方法。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`。

### 2.3. 用途

**➦ 条件语句优化**

```js
// bad
function getCities(province) {
  switch (province) {
    case "四川省":
      return ["成都市", "乐山市", "自贡市"];
    case "贵州省":
      return ["贵阳市", "遵义市"];
    case "云南省":
      return ["昆明市", "楚雄市"];
    default:
      return [];
  }
}

const res = getCities("四川省");
console.log(res); //  ["成都市", "乐山市", "自贡市"]
```

```js
// good
const citiesObj = {
  四川省: ["成都市", "乐山市", "自贡市"],
  贵州省: ["贵阳市", "遵义市"],
  云南省: ["昆明市", "楚雄市"]
} 

const res = citiesObj["四川省"];
console.log(res); //  ["成都市", "乐山市", "自贡市"]
```

```js
// better
const citiesObj = new Map()
  .set("四川省", ["成都市", "乐山市", "自贡市"])
  .set("贵州省", ["贵阳市", "遵义市"])
  .set("云南省", ["grape", "plum"]);

const res = citiesObj.get("四川省");
console.log(res); //  ["成都市", "乐山市", "自贡市"]
```

# ➲  Class

## 1. Class 基本语法

**➦ 概述**

JavaScript 生成对象传统方法是通过构造函数实现，如下所示：

```javascript
function Person(name, age) {
	this.name = name;
	this.age  = age;
}
Person.prototype.description = function() {
	return `name: ${this.name} age: ${this.age}`
}
let per = new Person(`Muzili`, 26);
```

上面这种写法跟传统的面向对象语言差异很大，很容易让新学习这门语言的程序员感到困惑。ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过 `class` 关键字，可以定义类。基本上，ES6  `class` 的绝大部分功能，ES5都可以做到，新的`class`写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的 “类” 改写如下所示：

```javascript
class Person {
  // 构造方法
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  description() {
    return `name: ${this.name} age: ${this.age}`;
  }
}
let per = new Person(`Muzili`, 28);
```

上面代码定义了一个“类”，可以看到里面有一个`constructor` 方法，这就是构造方法，而 `this` 关键字则代表实例对象。也就是说，ES5的构造函数 `Person`，对应ES6的 `Person` 类的构造方法。

`Person` 类除了构造方法，还定义了一个`description`方法。注意，定义“类”的方法的时候，前面不需要加上`function`这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。

ES6的类，完全可以看作构造函数的另一种写法。

```javascript
class Person {
  // ...
}

console.log(typeof Person) // "function"
console.log(Person === Person.prototype.constructor) // true
```

上面代码表明，类的数据类型就是函数，类本身就指向构造函数。

使用的时候，也是直接对类使用`new`命令，跟构造函数的用法完全一致。

构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。

**➦ constructor**

constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个空的constructor 方法会被默认添加。				

```javascript
class Object {}
// 等同于
class Object {
  constructor() {}
}
```

> 提示：
>
> 1. constructor 方法默认返回实例对象(即 `this` )，当然也可以通过 `return` 返回其他对象。
> 2. 创建对象实例时，必须加上 `new` 关键字。

**➦ 类的实例对象**

```javascript
class Student {
  constructor(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
  description() {
    console.log(`
        姓名：${this.name}
        年龄：${this.age}
        性别：${this.gender}
    `);
  }
}
// 创建类实例
let stu = new Student(`Petter`, `26`, `male`);
console.log(stu.hasOwnProperty(`name`)); // true
console.log(stu.hasOwnProperty(`age`)); // true
console.log(stu.hasOwnProperty(`gender`)); // true
console.log(stu.hasOwnProperty(`description`)); // false
console.log(stu.__proto__.hasOwnProperty(`description`)); // true
```

> 注意：
>
> \> 实例的属性除非显式定义在其本身(即定义在 this 对象上)，否则都是定义在原型上(即定义在 class 上)	

与 ES5 一样，类的所有实例共享一个原型对象。

```javascript
let stu1 = new Student();
let stu2 = new Student();
console.log(stu1.__proto__ === stu2.__proto__); // true
```

这也意味着，可以通过实例的 __proto__ 属性为“类”添加方法。

```javascript
stu1.__proto__.sayHello = () => {
    console.log(`Hello, Girl!`);
};
stu2.sayHello();
```

> 注意：
>
> \> 使用实例的 __proto__ 属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。

**➦ class 表达式**

class 语序使用表达式定义：

```javascript
let myClass = class meClass {
  getClassName() {
    return meClass.name;
  }
};
```

上述类名为 `myClass`，`meClass` 只能在类内部使用.

通过 class 表达式，可以写出立即执行的class

```javascript
let dog = new (class {
  constructor(name) {
    this.name = name;
  }
  sayName() {
    console.log(this.name);
  }
})("小黄");
dog.sayName(); // "小黄"
```

**➦ 不存在变量提升**

类不存在变量提升，这意味着创建类的实例时，必须先定义类。

**➦  私有方法、属性**

类不存在私有方法和私有属性，为了加以辨识，通常会在方法或属性前加下划线 `_`，但尽管如此，外部依然可以访问。

**➦  this 指向**

类的方法内部如果含有 this ，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。

```javascript
class Person {
  sayHello(name = `Admin`) {
    this.printf(name);
  }
  printf(str) {
    console.log(`Hello, ${str}`);
  }
}
let per = new Person();
per.sayHello(`Tom`);

let { sayHello } = per;
sayHello(`Jay`); // TypeError: Cannot read property 'printf' of undefined
```

要解决这个问题，主要有两种弄方案：

**方案1：在构造方法中动态绑定this**

```javascript
class Person {
  constructor() {
    // 动态绑定this
    this.sayHello = this.sayHello.bind(this);
  }
  // ...
}
```

**方案2：使用箭头函数**

```javascript
class Person {
  constructor() {
    // 动态绑定this
    this.sayHello = (name = `Admin`) => {
      this.printf(name);
    };
  }
  // ...
}
```

**➦  name 属性**

由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被 Class 继承，包括 name 属性。

```javascript
class Point {}
Point.name // "Point"
```

name 属性总是返回紧跟在 class 关键字后面的类名。

**➦  setter & getter**

与 ES5 一样，在“类”的内部可以使用`get`和`set`关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。

```javascript
class Person {
  constructor() {}
  get name() {
    console.log("call the get.");
    return "Admin";
  }
  set name(value) {
    console.log("call the set.");
  }
}
let per = new Person();
per.name = "Admin"; // set
console.log(`name: ${per.name}`); // get
```

上面代码中，`name` 属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。

**➦  静态方法（类方法）**

不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。静态方法声明需在方法前通过 `static` 关键字修饰。

```javascript
class Person {
  constructor() {}
  // static 修饰 -> 静态方法
  static sayHello() {
    console.log(`Hello`);
  }
  drinkWith(str) {
    console.log(`喝${str}!`);
  }
}
let per = new Person();
// 静态方法通过类名直接调用
Person.sayHello(); // Hello
per.sayHello(); // TypeError: per.sayHello is not a function
per.drinkWith(`龙井茶`);
```

> 注意：
>
> 1. 如果静态方法包含`this`关键字，这个`this`指的是类，而不是实例。

**➦  类的静态属性和实例属性**

静态属性指的是 Class 本身的属性，即 *Class.propName* ，而不是定义在实例对象（`this`）上的属性。

```javascript
class Person {}
Person.flag = true;
console.log(Person.flag); // true
```

上面写法定义了一个 Person 类，并定义了一个静态属性 `flag`

## 2. Class 继承

**➦  extends**

ES6 继承可通过 `extends` 关键字实现。

```javascript
// 定义Person类
class Person {
  constructor(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
  // 静态方法
  static sayHello() {
    console.log(`Hello.`);
  }
  // 实例方法
  play() {
    console.log(`Play game.`);
  }
}

// 定义Student类继承于Person
class Student extends Person {
  constructor(name, age, gender, major) {
    // 调用父类构造方法初始化父类实例属性
    super(name, age, gender);
    this.major = major;
  }
  // 重写父类方法
  play() {
    // 在子类中调用父类方法
    super.play();
    console.log(`Play basketball.`);
  }
  description() {
    console.log(
      ` 姓名：${this.name}            
        年龄：${this.age}            
        性别：${this.gender}            
        主修：${this.major}       
      `
    );
  }
}
let stu = new Student(`木子李`, `26`, `男`, `软件工程`);
stu.description();
// 调用从父类继承的父类方法
stu.play();
```

**➦  Object.getPropertyOf()**

该方法可以用来从子类上获取父类。

```js
console.log(Object.getPrototypeOf(Student) === Person); // true
```

因此，可以使用这个方法判断，一个类是否继承了另一个类。

**➦  super 关键字**

super 关键字指向父类，可作为函数调用，也可作为对象调用。

当super作为函数调用时，调用父类的构造方法。

当super作为对象调用时，可通过super关键字调用父类的属性和方法。

# ➲  Proxy

## 1. 基础

**Proxy** 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义。其功能非常类似于设计模式中的代理模式，该模式常用于三个方面：

- 拦截和监视外部对对象的访问
- 降低函数或类的复杂度
- 在复杂操作前对操作进行校验或对所需资源进行管理

ES6原生提供了`Proxy`构造函数，用来生成 `Proxy` 实例。

```js
const proxy = new Proxy(target, handler);
```

在支持 Proxy 的浏览器环境中，Proxy 是一个全局对象，可以直接使用。`target` 是被代理的对象，`handlder` 是声明了各类代理操作的对象，最终返回一个代理对象。外界每次通过代理对象访问 `target` 对象的属性时，就会经过 `handler` 对象，从这个流程来看，代理对象很类似 middleware（中间件）。那么 Proxy 可以拦截什么操作呢？最常见的就是 get（读取）、set（修改）对象属性等操作。此外，Proxy 对象还提供了一个 `revoke` 方法，可以随时注销所有的代理操作。在我们正式介绍 Proxy 之前，建议你对 Reflect 有一定的了解，它也是一个 ，它也是一个 ES6 新增的全局对象，详细信息请参考 [MDN Reflect](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect)。

**➦ 对象方法**

- [handler.apply()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/apply)
- [handler.construct()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/construct)
- [handler.defineProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/defineProperty)
- [handler.deleteProperty()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/deleteProperty)
- [handler.get()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get)
- [handler.getOwnPropertyDescriptor()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor)
- [handler.getPrototypeOf()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getPrototypeOf)
- [handler.has()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/has)
- [handler.isExtensible()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/isExtensible)
- [handler.ownKeys()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/ownKeys)
- [handler.preventExtensions()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/preventExtensions)
- [handler.set()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/set)
- [handler.setPrototypeOf()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/setPrototypeOf)

**➦ 基础示例**

```js
const target = { name: "Muzili", age: 28 };
const handler = {
  get(target, key, proxy) {
    const today = new Date();
    console.log(`GET request made for ${key} at ${today}`);
    return Reflect.get(target, key, proxy);
  },
};
const proxy = new Proxy(target, handler);
proxy.name;
// => "GET request made for name at Fri May 07 2021 14:55:47 GMT+0800 (中国标准时间)"
// => "Muzili"。
```

在上面的代码中，我们首先定义了一个被代理的目标对象 target，然后声明了包含所有代理操作的 handler 对象，接下来使用 Proxy(target, handler) 创建代理对象 proxy，此后所有使用 proxy 对 target 属性的访问都会经过 handler 的处理。

## 2. 场景

**➦ 抽离校验模块**

让我们从一个简单的类型校验开始做起，这个示例演示了如何使用 Proxy 保障数据类型的准确性：

```js
const numericDataStore = {
  count: 2,
  price: 10,
};

const proxy = new Proxy(numericDataStore, {
  set(target, key, value, proxy) {
    if (typeof value !== "number") {
      throw Error("numericDataStore 对象属性值只接收 number 类型。");
    }
    return Reflect.set(target, key, value, proxy);
  },
});

proxy.count = "10"; // numericDataStore 对象属性值只接收 number 类型
proxy.count = 10;
```

**➦ 私有属性**

在 JavaScript 或其他语言中，大家会约定俗成地在变量名之前添加下划线（`_`）来表明这是一个私有属性（并不是真正的私有），但我们无法保证真的没人会去访问或修改它。在下面的代码中，我们声明了一个私有的 appsecret，便于 api 这个对象内部的方法调用，但不希望从外部也能够访问 api._appsecret：

```js
const api = {
  _appsecret: "5732e4c9db7ff9f7",
  appID: "wx1695393264bf7d",
  wx: "gh_133b3cd88m3a",
};

api._appsecret = "123456789";
console.log(api._appsecret); // 123456789
```

很显然，约定俗成是没有束缚力的。使用 ES6 Proxy 我们就可以实现真实的私有变量了，下面针对不同的读取方式演示两个不同的私有化方法。

<u>第一种方法是使用 set / get 拦截读写请求并返回 undefined：</u>

```js
let api = {
  _appsecret: "5732e4c9db7ff9f7",
  appID: "wx1695393264bf7d",
  wx: "gh_133b3cd88m3a",
};

const RESTRICTED = ["_appsecret"];
api = new Proxy(api, {
  get(target, key, proxy) {
    if (RESTRICTED.indexOf(key) > -1) {
      throw Error(`${key} 为私有属性，不可访问`);
    }
    return Reflect.get(target, key, proxy);
  },
  set(target, key, value, proxy) {
    if (RESTRICTED.indexOf(key) > -1) {
      throw Error(`${key} 为私有属性，不可赋值`);
    }
    return Reflect.set(target, key, value, proxy);
  },
});

console.log(api._appsecret); // Uncaught Error: _appsecret 为私有属性，不可访问
api._appsecret = "123"; // Uncaught Error: _appsecret 为私有属性，不可赋值
```

<u>第二种方法是使用 `has` 拦截 `in` 操作：</u> 

```js
let api = {
  _appsecret: "5732e4c9db7ff9f7",
  appID: "wx1695393264bf7d",
  wx: "gh_133b3cd88m3a",
};

const RESTRICTED = ["_appsecret"];
api = new Proxy(api, {
  has(target, key) {
    return RESTRICTED.indexOf(key) > -1 ? false : Reflect.has(target, key);
  },
});

console.log("_appsecret" in api);
for (const key in api) {
  if (api.hasOwnProperty(key) && key === "_appsecret") {
    console.log(
      "This will never be logged because the proxy obscures _appsecret..."
    );
  }
}
```

# ➲  [Generator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Generator) 

Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。

Generator 函数有两个特征：

- `function` 关键字与函数名之间有一个星号（`*`）；
- 函数体内部使用 `yield` 表达式，表示不同的内部状态；

```js
function* hello() {
  yield  1;
  yield  2;
  return 3;
}

const p = hello();
console.log(p.next()); // {value: 1, done: false}
console.log(p.next()); // {value: 2, done: false}
console.log(p.next()); // {value: 3, done: true }
```

调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象。下一步，必须调用遍历器对象的`next`方法，使得指针移向下一个状态。也就是说，每次调用`next`方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个`yield`表达式（或`return`语句）为止。换言之，Generator 函数是分段执行的，`yield`表达式是暂停执行的标记，而`next`方法可以恢复执行。

总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的`next`方法，就会返回一个有着`value`和`done`两个属性的对象。`value`属性表示当前的内部状态的值，是`yield`表达式后面那个表达式的值；`done`属性是一个布尔值，表示是否遍历结束。

## 1. yield 

由于 Generator 函数返回的遍历器对象，只有调用`next`方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。`yield`表达式就是暂停标志。

遍历器对象的`next`方法的运行逻辑如下。

（1）遇到`yield`表达式，就暂停执行后面的操作，并将紧跟在`yield`后面的那个表达式的值，作为返回的对象的`value`属性值。

（2）下一次调用`next`方法时，再继续往下执行，直到遇到下一个`yield`表达式。

（3）如果没有再遇到新的`yield`表达式，就一直运行到函数结束，直到`return`语句为止，并将`return`语句后面的表达式的值，作为返回的对象的`value`属性值。

（4）如果该函数没有`return`语句，则返回的对象的`value`属性值为`undefined`。

需要注意的是，`yield`表达式后面的表达式，只有当调用`next`方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。

## 2. 异步应用

ES6 诞生以前，异步编程的方法，大概有下面四种。

- 回调函数
- 事件监听
- 发布/订阅
- Promise 对象

Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。

















